#!/bin/bash

if [[ ! -z "$SETX" ]]; then {
   set -x
} fi

# set -x
set -e

export CLANG=clang++-3.8

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
export COCL_HOME=$(dirname ${SCRIPT_DIR})

if [[ -f ${COCL_HOME}/bin/ir-to-opencl ]]; then {
    export COCL_BIN=${COCL_HOME}/bin
    export COCL_LIB=${COCL_HOME}/lib
} else {
    export COCL_BIN=${COCL_HOME}/build
    export COCL_LIB=${COCL_HOME}/build
} fi

# Using this weird bash, compared to other possibilities because:
# - getopts cant handle long options
# - would rather not make cocl dependent on python (although I know that tensorflow already is)
# - getopt non-gnu cant handle long options either
# - getopt gnu is not the default on Mac
# I *hope* that bash is fairly portable, across Linux, Mac, cygwin/msys64?

function display_help {
    cat <<EOF

    Usage: cocl [options] <targetfile>
      -c compile to .o only, dont link
      -o final output filepath

      Device IR optimization options
         These are applied to the device IR generation step
         This is before the OpenCL generation step
         These options strongly affect the success or not of the OpenCL generation step
         They will also affect the 'look' of the final OpenCL, which will influence whether
         different GPU drivers can read it, and probably affects final execution speed
         Optimization at this point is not important for speed, but does affect how
         easy the resulting IR is to parse, and convert to OpenCL
         Too much optimization makes the code long, and branching hard to disentangle
         Too little optimization causes lots of memory allocaiton/free, which invariably
         makes it hard to handle address spaces

         These options will mostly be passed through to opt-3.8

          -devicell-opt [OPTION]
             Passed through to opt-3.8

           Examples:

         --devicell-opt inline
             Try to inline OpenCL functions
             Generally required, otherwise you'll get errors about address space mismatch

         --devicell-opt mem2reg
             Try to convert heap allocations to registers
             Generally required, otherwise you'll get errors about address space mismatch

          -devicell-opt instcombine
             Pass to combine instructions where possible
             This generally has no downsides.  You want this :-)

          -devicell-opt O3
          -devicell-opt O2
          -devicell-opt O1
          -devicell-opt O0
             Set various standard optimization levels
             O0 works, as long as you set inline, mem2reg and instcombine
             O1 and O2 are probably good options in general
             O3 produces really long, gnarly llvm code, that is harder for the opencl generation
             pass to deal with

      OpenCL generation options:

        --add_ir_to_cl
             Add the original IR code into the generated OpenCL code, as comments
             Mainly useful to cuda-on-cl maintainers

      Options passed through to clang compiler:
        -fPIC
        -I<INCLUDEDIR>
        -g

      Options ignored currently:
        -O
        -G
        -D<SYMBOL>[=<VALUE>]
        -U
        -M
        -x <something>
        -iquote <something>
        -isystem <something>
        -compiler-options <something>
        -fno-canonical-system-headers
        -std<something>
        -compiler-bindir
        -gencode

EOF
}

# echo args "$@"
PASSTHRU=
export IROOPENCLARGS=
export DEVICELLOPT=
while [[ x$1 != x ]]; do {
    # echo 1 $1
    arr1=(${1//=/ })
    THISARG=${arr1[0]}
    DONE=0
    TWOLETTERS=${1:0:2}
    # echo TWOLETTERS [$TWOLETTERS]
    case "${TWOLETTERS}" in
        -I)
            # echo got include
            # need to check if theres a space or not
            if [[ $1 == -I ]]; then {
                INCLUDES="$INCLUDES -I$2"
                shift
            } else {
                INCLUDES="$INCLUDES $1"
            } fi
            DONE=1
            ;;
        -D)
            # PASSTHRU="$PASSTHRU $1"
            DONE=1
            ;;
        -O)
            # ignore...
            DONE=1
            ;;
        -G)
            # PASSTHRU="$PASSTHRU $1"
            # ignore
            DONE=1
            ;;
        -U)
            # PASSTHRU="$PASSTHRU $1"
            DONE=1
            ;;
        -x)
            # not sure why we are receiving -x cu? ignore for now
            shift
            DONE=1
            ;;
         *)
            ;;
    esac
    if [[ $DONE != 1 ]]; then {
        # echo THISARG ${THISARG}
        case ${THISARG} in
            -M)
                # not sure what this is, but it suppresses device IR generation...
                # => ignore
                # PASSTHRU="$PASSTHRU -M"
                ;;
            # -I)
            #    INCLUDES="$INCLUDES $1"
            #     ;;
            -c)
                COMPILE=1
                ;;
            -g)
                OPT_G=-g
                ;;
            -o)
                OUTPATH=$2
                shift
                ;;
            -iquote)
                # PASSTHRU="$PASSTHRU $1 $2"
                shift
                ;;
            -isystem)
                # PASSTHRU="$PASSTHRU $1 $2"
                shift
                ;;
             --devicell-opt)
                if [[ x$2 == x ]]; then {
                    echo Please provide a value for -devicell-opt
                    exit 1
                } fi
                DEVICELLOPT="${DEVICELLOPT} -$2"
                shift
                ;;
            --add_ir_to_cl)
                IROOPENCLARGS="${IROOPENCLARGS} $1"
                ;;
            -?)
                display_help
                exit 0
                ;;
            -h)
                display_help
                exit 0
                ;;
            --help)
                display_help
                exit 0
                ;;
            -gencode)
                # echo ignoring -gencode
                # clang doesnt like this => ignore
                # PASSTHRU="$PASSTHRU $1"
                ;;
            --compiler-bindir)
                # echo ignoring --compiler-bindir
                # clang doesnt like this => ignore
                # PASSTHRU="$PASSTHRU $1"
                ;;
            -fPIC)
                PASSTHRU="$PASSTHRU $1"
                ;;
            -fno-canonical-system-headers)
                # echo ignoring -fno-canonical-system-headers
                # clang doesnt like this => ignore
                # PASSTHRU="$PASSTHRU $1"
                ;;
            --compiler-options)
                # echo ignoring --compiler-options
                shift
                # echo ignoring compiler-options
                # clang doesnt like this => ignore
                # PASSTHRU="$PASSTHRU $1"
                ;;
            -std)
                # echo got -std
                # PASSTHRU="$PASSTHRU $1"
                ;;
            *)
                # echo adding $1 as input file
                if [[ x$INFILES != x ]]; then {
                    INFILES="$INFILES $1"
                } else {
                    INFILES="$1"
                } fi
                ;;
        esac
    } fi
    # esac
    # echo new passthru $PASSTHRU
    # echo doing shift
    shift
} done

INPATH=${INFILES}

export INCLUDES

if [[ x$INPATH == x ]]; then {
    echo Usage: $0 [-c] [-g] [[-Iincludepath]...] [-o outfile] [infile.cu]
    exit 1
} fi

# since tf feeds us weird postfixes like '.cu.cc' ,and '.cu.pic.d' (is that a foldername? unclear for now...), so
# we need to do something more robust than just assume the files end in '.cu' or '.o'
# so, we'll do a bash string split

# gets a file basename and postfix, for unknown postfix
# output: BASEPATH POSTFIX
# eg input: foo/bar/somefile.cu.cc
# outputs will be:
# BASEPATH=foo/bar/somefile
# POSTFIX=.cu.cc
function split_path {
    DIRNAME=$(dirname $1)

    BASENAME=$(basename $1)

    BASEARR=(${BASENAME//./ })
    BASEPATH=${DIRNAME}/${BASEARR[0]}

    LENARR=$((${#BASEARR[@]} - 1))
    ARGREST=
    for j in $(seq 1 ${LENARR}); do {
        ARGREST="$ARGREST.${BASEARR[$j]}";
    } done
    POSTFIX=$ARGREST
}

split_path ${INPATH}
INPUTBASEPATH=${BASEPATH}
INPUTPOSTFIX=${POSTFIX}

if [[ $OUTPATH ]]; then {
    OUTFILE=${OUTPATH}
} else {
    if [[ $COMPILE == 1 ]]; then {
        OUTFILE=${INPUTBASEPATH}.o
    } else {
        OUTFILE=${INPUTBASEPATH}
    } fi
} fi

split_path ${OUTFILE}
OUTPUTBASEPATH=${BASEPATH}
OUTPUTPOSTFIX=${POSTFIX}

if [[ x${NOCOCLREBUILD} == x ]]; then {
    (cd ${COCL_HOME}
         # make
    )
} fi

if [[ ! "$COMPILE" ]]; then {
    FINALPOSTFIX=${OUTPUTPOSTFIX}
    OUTPUTPOSTFIX=.o
} fi


OUTPUTARTIFACT=
if [[ ! "$COMPILE" ]]; then {
    OUTPUTARTIFACT=${OUTPUTBASEPATH}${FINALPOSTFIX}
} fi

OUTPUTBASEPATH=${OUTPUTBASEPATH} OUTPUTPOSTFIX=${OUTPUTPOSTFIX} PASSTHRU=${PASSTHRU} INPUTPOSTFIX=${INPUTPOSTFIX} \
    INPUTBASEPATH=${INPUTBASEPATH} OPT_G=${OPT_G} \
    make -B -f ${SCRIPT_DIR}/../share/cocl/cocl.Makefile ${OUTPUTARTIFACT}
